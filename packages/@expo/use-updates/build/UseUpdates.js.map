{"version":3,"file":"UseUpdates.js","sourceRoot":"","sources":["../src/UseUpdates.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Updates from 'expo-updates';\nimport { useEffect, useRef, useState } from 'react';\n\nimport {\n  UseUpdatesStateType,\n  UseUpdatesReturnType,\n  UseUpdatesEventType,\n  UseUpdatesEvent,\n} from './UseUpdates.types';\nimport { emitEvent, useUpdateEvents } from './UseUpdatesEmitter';\nimport { currentlyRunning, availableUpdateFromEvent } from './UseUpdatesUtils';\n\n/**\n * Calls `Updates.checkForUpdateAsync()` and refreshes the `availableUpdate` property with the result.\n * If an error occurs, the `error` property will be set.\n */\nexport const checkForUpdate = () => {\n  Updates.checkForUpdateAsync()\n    .then((result) => {\n      if (result.isAvailable) {\n        emitEvent({\n          type: UseUpdatesEventType.UPDATE_AVAILABLE,\n          manifest: result?.manifest || undefined,\n        });\n      } else {\n        emitEvent({\n          type: UseUpdatesEventType.NO_UPDATE_AVAILABLE,\n        });\n      }\n    })\n    .catch((error) => {\n      emitEvent({\n        type: UseUpdatesEventType.ERROR,\n        error,\n      });\n    });\n};\n/**\n * Downloads an update, if one is available, using `Updates.fetchUpdateAsync()`.\n * If an error occurs, the `error` property will be set.\n */\nexport const downloadUpdate = () => {\n  emitEvent({\n    type: UseUpdatesEventType.DOWNLOAD_START,\n  });\n  Updates.fetchUpdateAsync()\n    .then((result: any) => {\n      emitEvent({\n        type: UseUpdatesEventType.DOWNLOAD_COMPLETE,\n      });\n    })\n    .catch((error) => {\n      emitEvent({\n        type: UseUpdatesEventType.ERROR,\n        error,\n      });\n    });\n};\n\n/**\n * Runs an update by calling `Updates.reloadAsync()`. This should not be called unless there is an available update\n * that has already been successfully downloaded using `downloadUpdate()`.\n * If an error occurs, the `error` property will be set.\n */\nexport const runUpdate = () => {\n  Updates.reloadAsync().catch((error) => {\n    emitEvent({\n      type: UseUpdatesEventType.ERROR,\n      error,\n    });\n  });\n};\n\n/**\n * Calls `Updates.readLogEntriesAsync()` and sets the `logEntries` property to the results.\n * If an error occurs, the `error` property will be set.\n *\n * @param maxAge Max age of log entries to read, in ms. Defaults to 3600000 (1 hour).\n */\nexport const readLogEntries: (maxAge?: number) => void = (maxAge: number = 3600000) => {\n  Updates.readLogEntriesAsync(maxAge)\n    .then((logEntries) => {\n      emitEvent({\n        type: UseUpdatesEventType.READ_LOG_ENTRIES_COMPLETE,\n        logEntries,\n      });\n    })\n    .catch((error) => {\n      emitEvent({\n        type: UseUpdatesEventType.ERROR,\n        error,\n      });\n    });\n};\n\n/**\n * Hook that obtains information on available updates and on the currently running update.\n *\n * @param eventListener Optional event listener that will receive events from the `UseUpdatesEvent` emitter.\n *\n * @return the structures with information on currently running and available updates.\n *\n * @example\n * ```tsx UpdatesDemo.tsx\n * import { StatusBar } from 'expo-status-bar';\n * import React from 'react';\n * import { Pressable, Text, View } from 'react-native';\n *\n * import type { UseUpdatesEvent } from '@expo/use-updates';\n * import {\n *   useUpdates,\n *   checkForUpdate,\n *   downloadUpdate,\n *   runUpdate,\n *   UseUpdatesEventType,\n * } from '@expo/use-updates';\n *\n * export default function UpdatesDemo() {\n *   const eventListener = (event: UseUpdatesEvent) => {\n *     if (event.type === UseUpdatesEventType.DOWNLOAD_COMPLETE) {\n *       runUpdate();\n *     }\n *   };\n *\n *   const { currentlyRunning, availableUpdate } = useUpdates(eventListener);\n *\n *   // If true, we show the button to download and run the update\n *   const showDownloadButton = availableUpdate !== undefined;\n *\n *   // Show whether or not we are running embedded code or an update\n *   const runTypeMessage = currentlyRunning.isEmbeddedLaunch\n *     ? 'This app is running from built-in code'\n *     : 'This app is running an update';\n *\n *   return (\n *     <View style={styles.container}>\n *       <Text style={styles.headerText}>Updates Demo</Text>\n *       <Text>{runTypeMessage}</Text>\n *       <Button pressHandler={checkForUpdate} text=\"Check manually for updates\" />\n *       {showDownloadButton ? (\n *         <Button pressHandler={downloadUpdate} text=\"Download and run update\" />\n *       ) : null}\n *       <StatusBar style=\"auto\" />\n *     </View>\n *   );\n * }\n * ```\n */\nexport const useUpdates: (\n  eventListener?: (event: UseUpdatesEvent) => void\n) => UseUpdatesReturnType = (eventListener) => {\n  const [updatesState, setUpdatesState] = useState<UseUpdatesStateType>({\n    isUpdateAvailable: false,\n    isUpdatePending: false,\n  });\n\n  const eventListenerRef = useRef<((event: UseUpdatesEvent) => void) | undefined>();\n\n  useEffect(() => {\n    eventListenerRef.current = eventListener;\n  }, [eventListener]);\n\n  // Set up listener for events from automatic update requests\n  // that happen on startup, and use events to refresh the updates info\n  // context\n  useUpdateEvents((event) => {\n    eventListenerRef?.current && eventListenerRef?.current(event);\n\n    const { availableUpdate, error } = availableUpdateFromEvent(event);\n    switch (event.type) {\n      case UseUpdatesEventType.UPDATE_AVAILABLE:\n      case UseUpdatesEventType.NO_UPDATE_AVAILABLE:\n      case UseUpdatesEventType.ERROR:\n        setUpdatesState((updatesState) => ({\n          ...updatesState,\n          availableUpdate,\n          isUpdateAvailable: true,\n          error,\n          lastCheckForUpdateTimeSinceRestart: new Date(),\n        }));\n        break;\n      case UseUpdatesEventType.DOWNLOAD_COMPLETE:\n        setUpdatesState((updatesState) => ({\n          ...updatesState,\n          availableUpdate: availableUpdate || updatesState.availableUpdate,\n          isUpdateAvailable: true,\n          isUpdatePending: true,\n          lastCheckForUpdateTimeSinceRestart: new Date(),\n        }));\n        break;\n      case UseUpdatesEventType.READ_LOG_ENTRIES_COMPLETE:\n        setUpdatesState((updatesState) => ({\n          ...updatesState,\n          logEntries: event?.logEntries,\n        }));\n        break;\n      default:\n        break;\n    }\n  });\n\n  // Return the updates info and the user facing functions\n  return {\n    currentlyRunning,\n    ...updatesState,\n  };\n};\n"]}