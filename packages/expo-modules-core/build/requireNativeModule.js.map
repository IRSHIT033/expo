{"version":3,"file":"requireNativeModule.js","sourceRoot":"","sources":["../src/requireNativeModule.ts"],"names":[],"mappings":"AAAA,OAAO,kBAAkB,MAAM,sBAAsB,CAAC;AAEtD;;;;;;;;GAQG;AACH,MAAM,UAAU,mBAAmB,CAAmB,UAAkB;IACtE,MAAM,YAAY,GAChB,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,UAAU,CAAC;QACtC,UAAU,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC;QACpC,kBAAkB,CAAC,UAAU,CAAC,CAAC;IAEjC,IAAI,CAAC,YAAY,EAAE;QACjB,MAAM,IAAI,KAAK,CAAC,8BAA8B,UAAU,GAAG,CAAC,CAAC;KAC9D;IACD,OAAO,YAAY,CAAC;AACtB,CAAC","sourcesContent":["import NativeModulesProxy from './NativeModulesProxy';\n\n/**\n * Imports the native module registered with given name. In the first place it tries to load\n * the module installed through the JSI host object and then falls back to the bridge proxy module.\n * Notice that the modules loaded from the proxy may not support some features like synchronous functions.\n *\n * @param moduleName Name of the requested native module.\n * @returns Object representing the native module.\n * @throws Error when there is no native module with given name.\n */\nexport function requireNativeModule<ModuleType = any>(moduleName: string): ModuleType {\n  const nativeModule: ModuleType =\n    globalThis.expo?.modules?.[moduleName] ??\n    globalThis.ExpoModules?.[moduleName] ??\n    NativeModulesProxy[moduleName];\n\n  if (!nativeModule) {\n    throw new Error(`Cannot find native module '${moduleName}'`);\n  }\n  return nativeModule;\n}\n"]}